[
["index.html", "Applied SNA with R Chapter 1 Prerequisites", " Applied SNA with R George G. Vega Yon 2018-01-22 Chapter 1 Prerequisites Install R from CRAN: https://www.r-project.org/ (optional) Install Rstudio: https://rstudio.org While I find RStudio extreamly useful, it is not necesary to use it with R. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction This book will be build as part of a workshop on Applied Social Network Analysis with R. Its contents will be populated as the sessions take place, and for now there is particular program that we will follow, instead, we have the following workflow: Participants will share their data and what they need to do with it. Based on their data, I’ll be preparing the sessions trying to show attendees how would I approach the problem, and at the same time, teach by example about the R language. Materials will be published on this website and, hopefully, video recordings of the sessions. At least in the first version, the book will be organized by session, this is, one chapter per session. In general, we will besides of R itself, we will be using R studio and the following R packages: dplyr for data management, stringr for data cleaning, and of course igraph, netdiffuseR (a bit of a bias here), and statnet for our neat network analysis.1 Some of you may be wondering “what about ggplot2 and friends? What about tidyverse”, well, my short answer is I jumped into R before all of that was that popular. When I started plots were all about lattice, and after a couple of years on that, about base R graphics. What I’m saying is that so far I have not find a compelling reason to leave my “old-practices” and embrace all the tidyverse movement (religion?).↩ "],
["r-basics.html", "Chapter 3 R Basics 3.1 What is R 3.2 How to install packages", " Chapter 3 R Basics 3.1 What is R 3.2 How to install packages Nowadays there are two ways of installing R packages (that I’m aware of), either using install.packages, which is a function shipped with R, or use the devtools R package to install a package from some remote repository other than CRAN, here is a couple of examples: # This will install the igraph package from CRAN &gt; install.packages(&quot;netdiffuseR&quot;) # This will install the bleeding-edge version from the project&#39;s github repo! &gt; devtools::install_github(&quot;USCCANA/netdiffuseR&quot;) The first one, using install.packages, installs the CRAN version of netdiffuseR, whereas the second installs whatever version is plublished on https://github.com/USCCANA/netdiffuseR, which is usually called the development version. In some cases users may want/need to install packages from command line as some packages need extra configuration to be installed. But we won’t need to look at it now. "],
["week-1-sns-study.html", "Chapter 4 Week 1: SNS Study 4.1 The Social Network Study 4.2 Reading and cleaning the data 4.3 Retrieving the network 4.4 Plotting the network in igraph", " Chapter 4 Week 1: SNS Study 4.1 The Social Network Study 4.2 Reading and cleaning the data R has several ways of reading data in. You data can be Raw plain files like CSV, tab delimited or specified by column width, for which you can use the readr package; or it can be binary files like dta (Stata), Octave, SPSS, for which foreign can be used; or it could be excel files in which case you should be using readxl. In our case, the data for this session is in Stata13 format, and so we will be using readstata13. library(dplyr) library(magrittr) library(readstata13) # Reading the data dat &lt;- read.dta13(&quot;SNS datamerged081315edited.dta&quot;) # Taking a look at the file head(dat[,1:5]) ## t4_SubjectID School photoid sch_friend41 sch_friend42 ## 1 411104010 111 1 347 420 ## 2 411103015 111 2 424 205 ## 3 411603020 111 7 NA 505 ## 4 411103026 111 13 608 387 ## 5 411103016 111 14 NA NA ## 6 411502003 111 15 NA 265 For now, we won’t be using all ~2,000 columns of this data (which is mostly because we have a wide format dataset here), so we need to filter all this data. In order to do so, we can use the select function from the dplyr package dat_filtered &lt;- select( dat, School, photoid, matches(&quot;^sch_friend.+&quot;) ) The function matches allows us using regular expressions to select variables (reguwhat!?). Regular expressions are, as I once overheard, the poor man’s RA. In this case, instead of us having to look for all the variables that start with the pattern sch_friend, we use regular expressions to catch that, character by character, we have: ^: Line start sch_friend: Followed by sch_friend .+: Followed by anything not null. We will see more of this in the future. Now, if you don’t want to use dplyr to do this simple variable selection, you can always use the base R function subset. The following example is equivalent to what we just did using dplyr::select, although it can be slower2 dat_filtered &lt;- subset( dat, select = c( &quot;School&quot;, &quot;photoid&quot;, colnames(dat)[grepl(&quot;sch_friend.+&quot;, colnames(dat))] ) ) As you can see, the dplyr syntax is more clear. Now suppose that we want to create a unique id using the school and photo id. In this case, since both variables are numeric, a good way of doing it is to encode the id such that, for example, the last three x numbers are the photoid and the first ones are the school id. To do this we need to take into account the range of the variables. Here, photoid has the following range: (photo_id_ran &lt;- range(dat_filtered$photoid)) ## [1] 1 2074 As the variable spans up to 2074, we need to set the last 4 units of the variable to store the photoid. Again, we use dplyr to create this variable, and we will call it… id (mind blowing, right?): (dat_filtered %&lt;&gt;% mutate(id = School*10000 + photoid)) %&gt;% head %&gt;% select(School, photoid, id) ## School photoid id ## 1 111 1 1110001 ## 2 111 2 1110002 ## 3 111 7 1110007 ## 4 111 13 1110013 ## 5 111 14 1110014 ## 6 111 15 1110015 Wow, what happend in the last three lines of code! What is that %&gt;%? Well, that’s the piping operator, and it is a very nice way of writing nested function calls. In this case, instead of having write something like dat_filtered$id &lt;- dat_filtered$School*10000 + dat_filtered$photoid subset(head(dat_filtered), select = c(School, photoid, id)) 4.3 Retrieving the network library(tidyr) library(stringr) Optionally, we can use the tibble type of object which is an alternative to the actual data.frame. This object is claimed to provide more efficient methods for matrices and data frames. We will use it for this bit. dat_filtered &lt;- as_tibble(dat_filtered) # Maybe too much piping... but its cool! net &lt;- dat_filtered %&gt;% select(id, School, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -School) %&gt;% filter(!is.na(content)) %&gt;% mutate( friendid = School*10000 + content, year = str_extract(varname, &quot;(?&lt;=[a-z])[0-9]&quot;), nnom = str_extract(varname, &quot;(?&lt;=[a-z][0-9])[0-9]+&quot;) ) Let’s take a look at this step by step: First, we subset the data: We want to keep id, School, sch_friend* dat_filtered %&gt;% select(id, School, starts_with(&quot;sch_friend&quot;)) ## # A tibble: 2,164 x 78 ## id School sch_f… sch_f… sch_f… sch_… sch_… sch_… sch_… sch_… sch_… ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1110001 111 347 420 442 257 NA NA NA NA NA ## 2 1110002 111 424 205 536 NA 36 NA NA NA NA ## 3 1110007 111 NA 505 NA NA NA NA NA NA NA ## 4 1110013 111 608 387 93 119 627 610 569 NA NA ## 5 1110014 111 NA NA 599 NA 134 NA 377 41 233 ## 6 1110015 111 NA 265 NA 313 339 NA NA NA NA ## 7 1110020 111 79 214 440 NA NA NA NA 188 278 ## 8 1110022 111 37 258 71 143 427 470 371 NA NA ## 9 1110025 111 NA 185 NA NA NA NA NA NA NA ## 10 1110027 111 95 166 248 330 346 NA NA NA NA ## # ... with 2,154 more rows, and 67 more variables: sch_friend410 &lt;int&gt;, ## # sch_friend411 &lt;int&gt;, sch_friend412 &lt;int&gt;, sch_friend413 &lt;int&gt;, ## # sch_friend414 &lt;int&gt;, sch_friend415 &lt;int&gt;, sch_friend416 &lt;int&gt;, ## # sch_friend417 &lt;int&gt;, sch_friend418 &lt;int&gt;, sch_friend419 &lt;int&gt;, ## # sch_friend31 &lt;int&gt;, sch_friend32 &lt;int&gt;, sch_friend33 &lt;int&gt;, ## # sch_friend34 &lt;int&gt;, sch_friend35 &lt;int&gt;, sch_friend36 &lt;int&gt;, ## # sch_friend37 &lt;int&gt;, sch_friend38 &lt;int&gt;, sch_friend39 &lt;int&gt;, ## # sch_friend310 &lt;int&gt;, sch_friend311 &lt;int&gt;, sch_friend312 &lt;int&gt;, ## # sch_friend313 &lt;int&gt;, sch_friend314 &lt;int&gt;, sch_friend315 &lt;int&gt;, ## # sch_friend316 &lt;int&gt;, sch_friend317 &lt;int&gt;, sch_friend318 &lt;int&gt;, ## # sch_friend319 &lt;int&gt;, sch_friend11 &lt;int&gt;, sch_friend12 &lt;int&gt;, ## # sch_friend13 &lt;int&gt;, sch_friend14 &lt;int&gt;, sch_friend15 &lt;int&gt;, ## # sch_friend16 &lt;int&gt;, sch_friend17 &lt;int&gt;, sch_friend18 &lt;int&gt;, ## # sch_friend19 &lt;int&gt;, sch_friend110 &lt;int&gt;, sch_friend111 &lt;int&gt;, ## # sch_friend112 &lt;int&gt;, sch_friend113 &lt;int&gt;, sch_friend114 &lt;int&gt;, ## # sch_friend115 &lt;int&gt;, sch_friend116 &lt;int&gt;, sch_friend117 &lt;int&gt;, ## # sch_friend118 &lt;int&gt;, sch_friend119 &lt;int&gt;, sch_friend21 &lt;int&gt;, ## # sch_friend22 &lt;int&gt;, sch_friend23 &lt;int&gt;, sch_friend24 &lt;int&gt;, ## # sch_friend25 &lt;int&gt;, sch_friend26 &lt;int&gt;, sch_friend27 &lt;int&gt;, ## # sch_friend28 &lt;int&gt;, sch_friend29 &lt;int&gt;, sch_friend210 &lt;int&gt;, ## # sch_friend211 &lt;int&gt;, sch_friend212 &lt;int&gt;, sch_friend213 &lt;int&gt;, ## # sch_friend214 &lt;int&gt;, sch_friend215 &lt;int&gt;, sch_friend216 &lt;int&gt;, ## # sch_friend217 &lt;int&gt;, sch_friend218 &lt;int&gt;, sch_friend219 &lt;int&gt; Then, we reshape it to long format: By transposing all the sch_friend* to long dat_filtered %&gt;% select(id, School, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -School) ## # A tibble: 164,464 x 4 ## id School varname content ## &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1110001 111 sch_friend41 347 ## 2 1110002 111 sch_friend41 424 ## 3 1110007 111 sch_friend41 NA ## 4 1110013 111 sch_friend41 608 ## 5 1110014 111 sch_friend41 NA ## 6 1110015 111 sch_friend41 NA ## 7 1110020 111 sch_friend41 79 ## 8 1110022 111 sch_friend41 37 ## 9 1110025 111 sch_friend41 NA ## 10 1110027 111 sch_friend41 95 ## # ... with 164,454 more rows We remove all the NAs dat_filtered %&gt;% select(id, School, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -School) %&gt;% filter(!is.na(content)) ## # A tibble: 39,561 x 4 ## id School varname content ## &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1110001 111 sch_friend41 347 ## 2 1110002 111 sch_friend41 424 ## 3 1110013 111 sch_friend41 608 ## 4 1110020 111 sch_friend41 79 ## 5 1110022 111 sch_friend41 37 ## 6 1110027 111 sch_friend41 95 ## 7 1110029 111 sch_friend41 190 ## 8 1110030 111 sch_friend41 28 ## 9 1110032 111 sch_friend41 484 ## 10 1110035 111 sch_friend41 512 ## # ... with 39,551 more rows And finally, we create three new variables from this dataset: friendid, year, and nom_num (nomination number). All this using regular expressions: dat_filtered %&gt;% select(id, School, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -School) %&gt;% filter(!is.na(content)) %&gt;% mutate( friendid = School*10000 + content, year = str_extract(varname, &quot;(?&lt;=[a-z])[0-9]&quot;), nnom = str_extract(varname, &quot;(?&lt;=[a-z][0-9])[0-9]+&quot;) ) ## # A tibble: 39,561 x 7 ## id School varname content friendid year nnom ## &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1110001 111 sch_friend41 347 1110347 4 1 ## 2 1110002 111 sch_friend41 424 1110424 4 1 ## 3 1110013 111 sch_friend41 608 1110608 4 1 ## 4 1110020 111 sch_friend41 79 1110079 4 1 ## 5 1110022 111 sch_friend41 37 1110037 4 1 ## 6 1110027 111 sch_friend41 95 1110095 4 1 ## 7 1110029 111 sch_friend41 190 1110190 4 1 ## 8 1110030 111 sch_friend41 28 1110028 4 1 ## 9 1110032 111 sch_friend41 484 1110484 4 1 ## 10 1110035 111 sch_friend41 512 1110512 4 1 ## # ... with 39,551 more rows The regular expression (?&lt;=[a-z]) matches a string that is preceeded by any letter from a to z, whereas the expression [0-9] matches a single number. Hence, from the string &quot;sch_friend12&quot;, the regular expression will only match the 1, as it is the only number followed by a letter. On the other hand, the expression (?&lt;=[a-z][0-9]) matches a string that is preceeded by a letter from a to z and a number from 0 to 9; and the expression [0-9]+ matches a string of numbers–so it could be more than one. Hence, from the string &quot;sch_friend12&quot;, we will get 2. We can actually se this str_extract(&quot;sch_friend12&quot;, &quot;(?&lt;=[a-z])[0-9]&quot;) ## [1] &quot;1&quot; str_extract(&quot;sch_friend12&quot;, &quot;(?&lt;=[a-z][0-9])[0-9]+&quot;) ## [1] &quot;2&quot; Now that we have this edgelist, we can create an igraph object vertices &lt;- dat_filtered %&gt;% select(id, School) Let’s now use the function graph_from_data_frame to create an igraph object: library(igraph) ig_year1 &lt;- net %&gt;% filter(year == &quot;1&quot;) %&gt;% select(id, friendid) %&gt;% graph_from_data_frame( vertices = vertices ) ## Error in graph_from_data_frame(., vertices = vertices): Some vertex names in edge list are not listed in vertex data frame Ups, it seems that individuals are making nominations to other students that were not included on the survery. How to solve that? Well, it all depends on what you need to do! In this case, we will go for the quietly-remove-em’-and-don’t-tell strategy: ig_year1 &lt;- net %&gt;% filter(year == &quot;1&quot;, School == 111) %&gt;% # Extra line, all nominations must be in ego too. filter(friendid %in% id) %&gt;% select(id, friendid) %&gt;% graph_from_data_frame( vertices = vertices ) 4.4 Plotting the network in igraph plot(ig_year1) # Creating a subgraph ig_year1_111 &lt;- induced_subgraph( ig_year1, which(degree(ig_year1) &gt; 0 &amp; V(ig_year1)$School == 111) ) # Getting colors cols &lt;- V(ig_year1_111)$School %&gt;% as.factor cols &lt;- colors()[cols] # Fancy graph set.seed(1) plot( ig_year1_111, vertex.size = degree(ig_year1_111)/4, vertex.label = NA, edge.arrow.size = .25, vertex.color = cols, layout = layout_with_fr ) Besides of having nice syntax, dplyr offers optimized routines to handle your data. I personally use it specifically for that, as that can be nice when you are dealing with relatively large datasets.↩ "],
["applications.html", "Chapter 5 Applications 5.1 Example one 5.2 Example two", " Chapter 5 Applications Some significant applications are demonstrated in this chapter. 5.1 Example one 5.2 Example two "],
["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
