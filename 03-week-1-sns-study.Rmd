# Week 1: SNS Study

## The Social Network Study

## Reading and _cleaning_ the data

R has several ways of reading data in. You data can be Raw plain files like CSV, tab delimited or specified by column width, for which you can use the [`readr`](https://cran.r-project.org/package=readr) package; or it can be binary files like dta (Stata), Octave, SPSS, for which [`foreign`](https://cran.r-project.org/package=readr) can be used; or it could be excel files in which case you should be using [`readxl`](https://cran.r-project.org/package=readxl). In our case, the data for this session is in Stata13 format, and so we will be using [`readstata13`](https://cran.r-project.org/package=readstata13).

```{r 03-read-data, message=FALSE}
library(dplyr)
library(magrittr)
library(readstata13)

# Reading the data
dat <- read.dta13("SNS datamerged081315edited.dta")

# Taking a look at the file
head(dat[,1:5])
```

For now, we won't be using all ~2,000 columns of this data (which is mostly because we have a wide format dataset here), so we need to filter all this data. In order to do so, we can use the `select` function from the `dplyr` package

```{r 03-filtering-data-pipe, cache=TRUE}
dat_filtered <- select(
  dat,
  School, photoid,
  matches("^sch_friend.+")
  )
```

The function `matches` allows us using regular expressions to select variables (reguwhat!?). Regular expressions are, as I once overheard, _the poor man's RA_. In this case, instead of us having to look for all the variables that start with the pattern `sch_friend`, we use regular expressions to catch that, character by character, we have:

*   `^`: Line start
*   `sch_friend`: Followed by `sch_friend`
*   `.+`: Followed by anything not null.

We will see more of this in the future. Now, if you don't want to use `dplyr` to do this simple variable selection, you can always use the base R function `subset`. The following example is equivalent to what we just did using `dplyr::select`, although it can be slower^[Besides of having nice syntax, `dplyr` offers optimized routines to handle your data. I personally use it specifically for that, as that can be nice when you are dealing with relatively large datasets.]


```{r 03-filter-no-pipe, eval=FALSE}
dat_filtered <- subset(
  dat,
  select = c(
    "School", "photoid",
    colnames(dat)[grepl("sch_friend.+", colnames(dat))]
    )
  )

```

As you can see, the `dplyr` syntax is more clear.

Now suppose that we want to create a unique id using the school and photo id. In this case, since both variables are numeric, a good way of doing it is to encode the id such that, for example, the last three `x` numbers are the photoid and the first ones are the school id. To do this we need to take into account the range of the variables. Here, `photoid` has the following range:

```{r 03-idrange}
(photo_id_ran <- range(dat_filtered$photoid))
```

As the variable spans up to `r photo_id_ran[2]`, we need to set the last `r nchar(photo_id_ran[2])` units of the variable to store the `photoid`. Again, we use `dplyr` to create this variable, and we will call it... `id` (mind blowing, right?):

```{r 03-newid}
(dat_filtered %<>% mutate(id = School*10000 + photoid)) %>%
  head %>%
  select(School, photoid, id)
```

Wow, what happend in the last three lines of code! What is that `%>%`? Well, that's the [piping operator](http://r4ds.had.co.nz/pipes.html), and it is a very nice way of writing nested function calls. In this case, instead of having write something like

```r
dat_filtered$id <- dat_filtered$School*10000 + dat_filtered$photoid
subset(head(dat_filtered), select = c(School, photoid, id))
```

## Retrieving the network

```{r 03-loading-tidyr-stringr, message=FALSE}
library(tidyr)
library(stringr)
```

Optionally, we can use the `tibble` type of object which is an alternative to the actual `data.frame`. This object is claimed to provide _more efficient methods for matrices and data frames_. We will use it for this bit.

```{r 03-tibble}
dat_filtered <- as_tibble(dat_filtered)
```

```{r 03-reshape}
# Maybe too much piping... but its cool!
net <- dat_filtered %>% 
  select(id, School, starts_with("sch_friend")) %>%
  gather(key = "varname", value = "content", -id, -School) %>%
  filter(!is.na(content)) %>%
  mutate(
    friendid = School*10000 + content,
    year     = str_extract(varname, "(?<=[a-z])[0-9]"),
    nnom     = str_extract(varname, "(?<=[a-z][0-9])[0-9]+")
  )
```

Let's take a look at this step by step:

1.  First, we subset the data: We want to keep `id, School, sch_friend*`

    ```{r}
    dat_filtered %>% 
      select(id, School, starts_with("sch_friend"))
    ```
    
2.  Then, we reshape it to _long_ format: By transposing all the `sch_friend*` to long

    ```{r}
    dat_filtered %>% 
      select(id, School, starts_with("sch_friend")) %>%
      gather(key = "varname", value = "content", -id, -School)
    ```
    
3.  We remove all the `NAs`

    ```{r}
    dat_filtered %>% 
      select(id, School, starts_with("sch_friend")) %>%
      gather(key = "varname", value = "content", -id, -School) %>%
      filter(!is.na(content))
    ```
    
4.  And finally, we create three new variables from this dataset: `friendid`, `year`, and `nom_num` (nomination number). All this using regular expressions:
    
    ```{r}
    dat_filtered %>% 
      select(id, School, starts_with("sch_friend")) %>%
      gather(key = "varname", value = "content", -id, -School) %>%
      filter(!is.na(content)) %>%
      mutate(
        friendid = School*10000 + content,
        year     = str_extract(varname, "(?<=[a-z])[0-9]"),
        nnom     = str_extract(varname, "(?<=[a-z][0-9])[0-9]+")
        )
    ```
    
    The regular expression `(?<=[a-z])` matches a string that is preceeded by any letter from _a_ to _z_, whereas the expression `[0-9]` matches a single number. Hence, from the string `"sch_friend12"`, the regular expression will only match the `1`, as it is the only number followed by a letter. On the other hand, the expression `(?<=[a-z][0-9])` matches a string that is preceeded by a letter from _a_ to _z_ and a number from _0_ to _9_; and the expression `[0-9]+` matches a string of numbers--so it could be more than one. Hence, from the string `"sch_friend12"`, we will get `2`. We can actually se this 
    
    ```{r 03-miniregex}
    str_extract("sch_friend12", "(?<=[a-z])[0-9]")
    str_extract("sch_friend12", "(?<=[a-z][0-9])[0-9]+")
    ```
    
  
Now that we have this edgelist, we can create an igraph object

```{r 03-vertex}
vertices <- dat_filtered %>% 
  select(id, School)
```

Let's now use the function `graph_from_data_frame` to create an `igraph` object:

```{r 03-igraph, message=FALSE, error = TRUE}
library(igraph)

ig_year1 <- net %>%
  filter(year == "1") %>%
  select(id, friendid) %>%
  graph_from_data_frame(
    vertices = vertices
    )
```

Ups, it seems that individuals are making nominations to other students that were not included on the survery. How to solve that? Well, it all depends on what you need to do! In this case, we will go for the _quietly-remove-em'-and-don't-tell_ strategy:

```{r 03-igraph-bis, cache=TRUE}

ig_year1 <- net %>%
  filter(year == "1") %>%
  
  # Extra line, all nominations must be in ego too.
  filter(friendid %in% id) %>% 
  
  select(id, friendid) %>%
  graph_from_data_frame(
    vertices = vertices
    )

```

## Plotting the network in igraph

### Single plot

```{r 03-plot-raw, cache=TRUE}
plot(ig_year1)
```

```{r 03-plot-neat1, fig.cap="Friends network in time 1 for school 111. The graph excludes isolates."}

# Creating a subgraph
ig_year1_111 <- induced_subgraph(
  ig_year1,
  which(degree(ig_year1, mode = "all") >= 1 & V(ig_year1)$School == 111)
)

# Fancy graph
set.seed(1)
plot(
  ig_year1_111,
  vertex.size     = degree(ig_year1_111)/4,
  vertex.label    = NA,
  edge.arrow.size = .25,
  layout          = layout_with_fr
  )
```

We can actually write this as a function so that, instead of us copying and pasting the code $n$ times (supposing that we want to crate a plot similar to this $n$ times), we just need t

### Multiple plots

```{r 03-myplot-def}
myplot <- function(
  net,
  schoolid,
  mindgr = 1,
  vcol   = "tomato",
  ...) {
  
  # Creating a subgraph
  subnet <- induced_subgraph(
    net,
    which(degree(net, mode = "all") >= mindgr & V(net)$School == schoolid)
  )
  
  # Fancy graph
  set.seed(1)
  plot(
    subnet,
    vertex.size     = degree(subnet)/4,
    vertex.label    = NA,
    edge.arrow.size = .25,
    vertex.color    = vcol,
    layout          = layout_with_fr,
    ...
    )
}
```

```{r 03-myplot-call, fig.cap="All 5 schools in time 1. Again, the graphs exclude isolates."}
# Plotting all together
oldpar <- par(no.readonly = TRUE)
par(mfrow = c(2, 3), mai = rep(0, 4), oma= c(1, 0, 0, 0))
myplot(ig_year1, 111, vcol = "tomato")
myplot(ig_year1, 112, vcol = "steelblue")
myplot(ig_year1, 113, vcol = "black")
myplot(ig_year1, 114, vcol = "gold")
myplot(ig_year1, 115, vcol = "white")
par(oldpar)

# A fancy legend
legend(
  "bottom",
  legend = c(111, 112, 113, 114, 115),
  pt.bg  = c("tomato", "steelblue", "black", "gold", "white"),
  pch    = 21,
  cex    = 1,
  bty    = "n",
  title  = "Code"
  )
```

*   `oldpar <- par(no.readonly = TRUE)` This line stores the current parameters for plotting. Since we are going to be changing them, we better make sure we are able to go back!.

*   `par(mfrow = c(2, 3), mai = rep(0, 4), oma=rep(0, 4))` Here we are setting various things at the same time. `mfrow` specifies how many _figures_ will be drawn and in what order, in particular, we are asking the plotting device to allow for 2*3 = 6 plots organized in 2 rows and 3 columns, and these will be drawn by row.
    
    `mai` specifies the size of the margins in inches. Setting all margins equal to zero (which is what we are doing now) gives more space to the network itself. The same is true for `oma`. See `?par` for more info.
    

*   `myplot(ig_year1, ...)` This is simply calling our plotting function. The neat part of this is that, since we set `mfrow = c(2, 3)`, R takes care of _distributing_ the plots in the device.

*   `par(oldpar)` Finally, this line allows us to restore the plotting parameters.


    






